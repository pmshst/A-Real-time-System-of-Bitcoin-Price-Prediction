"""Script to gather market data from OKCoin Spot Price API."""
import requests
from pytz import utc
from datetime import datetime
from pymongo import MongoClient
from apscheduler.schedulers.blocking import BlockingScheduler
from pymongo import MongoClient
import sys
import numpy as np
import pandas as pd
import bigfloat as bg
import logging
import time
import math
from numpy.linalg import norm
if not sys.warnoptions:
    import warnings
    warnings.simplefilter("ignore")

client = MongoClient()
database = client['okcoindb']
collection = database['historical_data']
collection_result = database['prediction_result']

logger = logging.getLogger('bitcoin_prediction')
hdlr = logging.FileHandler('bitcoin_prediction.log')
#formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
formatter = logging.Formatter('%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s',
                datefmt = '%Y-%m-%d %A %H:%M:%S')
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
ch.setFormatter(formatter)
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.addHandler(ch)
logger.setLevel(logging.DEBUG)


def predict_dpi(x, s):
    """Predict the average price change Δp_i, 1 <= i <= 3.

    Args:
        x: A numpy array of floats representing previous 180, 360, or 720 prices.
        s: A 2-dimensional numpy array generated by choose_effective_centers().

    Returns:
        A big float representing average price change Δp_i.
    """
    num = 0
    den = 0
    for i in range(len(s)):
        y_i = s[i, len(x)]
        x_i = s[i, :len(x)]
        exp = bg.exp(-0.25 * norm(x - x_i) ** 2)
        num += y_i * exp
        den += exp
    return num / den

def predict_dps(prices,v_ask, v_bid, s1, s2, s3, w, t=0.001):
    """Predict average price changes (final estimations Δp) over the third
       time period.

    Args:
        prices: A numpy array of floats representing prices over the third time
            period.
        v_bid: A numpy array of floats representing total volumes people are
            willing to buy over the third time period.
        v_ask: A numpy array of floats representing total volumes people are
            willing to sell over the third time period.
        s1: A 2-dimensional numpy array generated by choose_effective_centers()
        s2: A 2-dimensional numpy array generated by choose_effective_centers().
        s3: A 2-dimensional numpy array generated by choose_effective_centers().
        w: A tuple (w0, w1, w2, w3, w4) generated by find_parameters_w().

    Returns:
        A numpy array of floats. Each array element represents the final
        estimation Δp.
    """
    #dps = []
    w0, w1, w2, w3, w4 = w
    ts1 = prices[-180:]
    ts2 = prices[-360:]
    ts3 = prices[0:720]
    dp1 = predict_dpi(ts1, s1)
    dp2 = predict_dpi(ts2, s2)
    dp3 = predict_dpi(ts3, s3)
    r = (v_bid[719] - v_ask[719]) / (v_bid[719] + v_ask[719])
    if(math.isnan(dp1)):
        dp1 = 0
    if(math.isnan(dp2)):
        dp2 = 0
    if(math.isnan(dp3)):
        dp3 = 0
    dp = w0 + w1 * dp1 + w2 * dp2 + w3 * dp3 + w4 * r
    # print('dp', dp)
    position = 0
    if(dp > t):
        position =1
    elif(dp < -t):
        position = -1
    else:
        position = 0
    return position, dp


w=np.array([0.0, 8.116235234688582e-07, 7.984229407696678e-07, -1.302544194313926e-06, -4.032949162348384e-06])

s1 = pd.read_csv('s1.csv').values
s2 = pd.read_csv('s2.csv').values
s3 = pd.read_csv('s3.csv').values

#s1 = pd.read_csv('BTCs1_no_ask.csv').values
#s2 = pd.read_csv('BTCs2_no_ask.csv').values
#s3 = pd.read_csv('BTCs3_no_ask.csv').values
# BTCs1_no_ask

prices = []
dates = []
v_asks = []
v_bids = []
num_points = 720

def continue_prideict():
    current_num_points = collection.count()
    NUMBER = current_num_points - 720
    for doc in collection.find().skip(NUMBER):
        dates.append(doc['date'])
        prices.append(doc['price'])
        v_asks.append(doc['v_ask'])
        v_bids.append(doc['v_bid'])

    # logger.info(len(prices))
    # logger.info(dates[-1])
    # logger.info(prices[-1])
    position, dp = predict_dps(prices, v_asks, v_bids, s1, s2, s3, w, t=0.00000001)
    next_price = prices[-1]
    if math.isnan(dp):
        logger.info('dp is NaN')
        #next_price = prices[-1]
    else:

        next_price += dp
    # logger.info(position)
    # logger.info(dp)
    # logger.info(next_price)
    return dates[-1], position, dp, next_price, prices[-1]

if __name__ == '__main__':
   while True:
     # mongodb do not support big float
     last_date, position, dp, next_price, currnet_price = continue_prideict()
     time.sleep(10)
     last_date1, position1, dp1, next_price1, currnet_price1 = continue_prideict()
     if(last_date1 > last_date):
         dict_result = {'date': last_date1, 'true_price': currnet_price1,'last_inteval_price':currnet_price, 'predicted_price': float(next_price), 'trading_strategy': position}
         logger.info('insert to mongod')
         logger.info(dict_result)
         collection_result.insert(dict_result)


